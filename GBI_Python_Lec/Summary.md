## Виртуальные окружения Python
Python умеет работать лишь с одной версией каждой библиотеки и ставит её в папку общую для всех пользователей. Из-за этого возникает три проблемы:
* разным проектам могут потребоваться разные версии библиотек (и далеко не всегда самая новая подходит лучше старых)
* пользователь без прав администратора вообще не может установить библиотеку, потому что у него нет доступа на запись к этой общей папке
* в системе может быть установлено несколько версий интерпретатора, у каждого из которых свой набор библиотек. При установке библиотек и запуске программы довольно легко забыть, какая из версий python используется

Решение - для каждого проекта создавать своё виртуальное окружение (локальная “копия” python нужной версии, плюс набор всех библиотек (конкретных версий), которые нужны этому проекту).*

### Создание виртуального окружения

Чтобы создать виртуальное окружение, необходимо запустить модуль venv и указать скрытую папку, в которой виртуальное окружение будет храниться (."name folder").

1. Зайти в папку проекта:

        cd "name folder project"

2. Запустить модуль venv:

        python -m venv ."name folder"

*Если у вас есть предпочтения по версии python, которая необходима, то модуль venv следует запускать при помощи той версии python, которую мы собираемся использовать в дальнейшем. Например, python3.6 -m venv ."name folder"*

*Если требуются библиотеки, которые устанавливать долго и нудно (например, tensorflow), а в системе они уже установлены, то можно добавить ключ --system-site-packages, тогда ваше окружение будет использоваться как дополнение к системному: python -m venv ."name folder" --system-site-packages*

### Активация виртуального окружения

В Windows команда:

    .venv\Scripts\activate.bat

В Linux/MacOS команда:

    source .venv/bin/activate

*(!) Окружение деактивируется каждый раз, когда терминал (консоль, командная строка) закрывается, так что при включении командной строки надо всякий раз активировать окружение*

Деактивировать окружение вручную команда:

    deactivate

### Работа в виртуальном окружении

После активации команды python и pip будут работать с этим окружением.

Устанавка библиотеки (в активированном окружении):

    pip install "some package"

или

    python -m pip install "some package"

Все библиотеки, которые вы установите, будут относиться только к этому проекту и будут подключаться после активации.

Запуск скриптов:

    python "script.py"

### Хранение конфигурации
Полезно завести файл requirements.txt (это стандартное имя), в котором будут перечислены все установленные библиотеки. Создать этот файл можно командой:

    pip freeze > requirements.txt

Помимо названий библиотек эта команда сохраняет также версии пакетов. Благодаря этому любой человек, использующий ваш проект (или вы сами на другом компьютере), можете одной командой установить все необходимые библиотеки. Притом вы избежите возможных багов, возникающих из-за различий в версиях библиотек на разных компьютерах. Установить библиотеки из файла requirements.txt можно командой:

    pip install -r requirements.txt

### Использование вместе с системой контроля версий git

Добавить папку вашего виртуального окружения ."name folder" в .gitignore:

    echo '.venv/' >> .gitignore

*Этой папке не место в репозитории: она очень объемная, а её отслеживание не даст вам серьезных преимуществ, но создаст лишние проблемы (виртуальные окружения нельзя просто так перенести с компьютера на компьютер, т.к. они зависят от того, в какой папке установлен python и какой версии).*

Чтобы система контроля версий отслеживала, какие библиотеки требуются вашему проекту, файл requirements.txt стоит добавить:

    git add requirements.txt
    git commit -m "Store requirements" -- requirements.txt

## Базовый синтаксис и типы данных

### Отступы

Отступы в Python играют огромную роль, стоит поставить на 1 пробел меньше,
чем нужно и программа будет не рабочая.Отступом отделяется блок кода, который находится внутри операторов ветвления, циклов, функций и тд. Обычно внутри VSC отступы ставятся автоматически.

*1 отступ =  TAB или 4 пробела*

Но необязательно это кнопка TAB или 4 пробела, можно настроить чему равен
отступ

### Комментирование
Комментирование многострочное:

    """
    
    line code
    ...
    line code

    """

Комментирование построчное:

    # line code

Комментирование (горячие клавиши):

**ctrl+K+C** - добавление выделенного кода в комметарий

**ctrl+K+U** - исключение выделенного кода из комметария

### Типы данных

* int - целые числа
* float - дробные числа
* bool - логический тип данных
* str -строка

*В python динамическая типизация данных.*

#### Приведение к опредленному типу данных:

    a = ...
    b = int(a) - приведение к целому числу, если а число
    b = str(a) - приведение к строковому типу данных
    b = bool(a) - приведение к логическому типу данных, если а > 0 или строка, то true

### Операции

#### Присвоение значения переменной: 

    name variable = value variable (для int, float, bool)
    name variable = 'value variable' (для str)
    name variable = "value variable" (для str)

Для вывода в строке символа " или ' нужно перед ним поставить \

#### Вывод:

    print ('other') - вывод иного текста и символов (other)
    print (a) - значение переменной (a)
    print (type(a)) - тип данных переменной

    print (a,b,'other') - значание переменных a, b и other 
    print (f"{a} {b} other") - значание переменных a, b и other  
    print ("{} {} other".format(a,b)) - значание переменных a, b и other 

#### Ввод:

    input() - ввод
    input('Enter ...:') - добавление указание перед вводом в той же строке
    a = input() - ввод с присвоением переменной
    a, b = 1, 2 - множественное присваивание 

#### Арифметические операции:

    '+' сложение
    '-' разница
    '*' умножение
    '/' деление
    '%' остаток от деления
    '//' целочисленное деление (округляет до целого в меньшую сторону)
    '**' возведение в степень

#### Округление чисел:

    round(a,b)

    a - число, числовая переменнная
    b - кол-во знаков после запятой

#### Логические операции:

    '>' больше
    '<' меньше
    '>=' больше или равно
    '<=' меньше или равно
    '==' равенство
    '!=' не равенство
    'not' не (отрицание)
    'and' и (конъюкция)
    'or' или (дизъюнкция)

### Управляющие констуркции

#### Условия if, if-else 

    if condition:
        operator 1
        ...
        operator n
    else:
        operator n+1
        ...
        operator n+m

Вариант использования операторов else-if в связке **elif**:

    if condition1:
        operator
    elif condition2:
        operator
    ...
    elif condition(n):
        operator
    else:
        operator

 Сложные условия с логическими операторами **and**, **or**, **not**:

    if condition1 and condition2:
        operator
    if condition3 or condition4:
        operator

#### Циклы while, while-else

    wile condition:
        operator 1
        operator 2
        ...
        operator n
    else:
        operator n+1
        ...
        operator n+m

Блок **else** выполняется, когда основное тело цикла перестает работать **самостоятельно**.

Использовать блок **break** нежелательно, в объектно-ориентированном программировании (ООП) нет такого понятия. Лучше использовать метод "Флага":

    n = int(input())
    flag = True
    i = 2
    while flag:
        if n % i == 0:
            flag = False
            print (i)
        elif i > n // i:
            print (n)
            flag = False
        i += 1

#### Цикл for, функция range()

    for i in range(...)
        operator 1
        ...
        operator n

* **range** выдает значения из диапазона с шагом 1.
* Если указано только одно число - от 0 до заданного числа.
* Если нужен другой шаг, третьим аргуметом можно задать приращение

Можно использовать цикл **for()** и со строками, так как у строк есть нумерация, как у массивов начинается с 0:

    for i in 'string'
        oprint (i)

### Методы для работы со строками

Размер строки:

    len(text)

Преобразование регистра строки:

    text.lower()     - перевод в нижний регистр
    text.upper()     - перевод в верхний регистр
    text.swapcase()  - перевод нижнего регистра в верхний, а верхнего в нижний

Замена последовательности символов в строке на другую последовательность:

    text.replace(old,new,[count])  - old - str, подстрока или символ который меняем
                                     new - str, подстрока или символ на который меняем
                                     count - int, сколько раз меняем

Подсчет кол-ва символов/подстрок в строке:

    text.count('')

Поиск позиции, в к-й находится первый символ подстроки первого совпадения:

    text.find('')
    text.rfind('')  - поиск ведется с правой стороны

    print('word' in text)  - выводит true/false - есть ли слово в строке

Удаление символов из строки:

    text.strip('')        по умолчанию удаляются пробелы и символы :\t\n\r\f\v
    text.lstrip('')     - метод .strip, но только с левой стороны
    text.rstrip('')     - метод .strip, но только с правой стороны

Разбиение и сбор списка строк:

    text.split('',-1)     - разбиение строки на части с возвращением списка строк
                            '' - разделитель, может содержать как один, так и несколько символов;
                            -1 - int, сколько раз делить строку, по умолчанию -1 - неограниченно.
                            с разделителем по умолчанию пробельные символы также удаляются в начале и в конце строки
                            по умолчанию метод разбивает строку не по одному пробельному символу, а по любому количеству

    text_new = ','.join(text)   - cобор списка строк в одну строку с разделителем, который указан перед join


### Работа с срезами

    text = 'съешь еще этих мягких французских булок

    print(text[0])              #c
    print(text[1])              #ъ
    print(text[len(text)-1])    #к
    print(text[-1])             #к
    print(text[:])              #cъешь еще ... (до конца строки)
    print(text[:2])             #съ
    print(text[len(text):2])    #ок
    print(text[2:9])            #ешь еще
    print(text[6:-18])          #еще этих мягких
    print(text[0:len(text):6])  #сеикакл
    print(text[::6])            #сеикакл

## Коллекции данных
### Списки
Список - это упорядоченный конечный набор элементов. Это тот же массив, в котором можно хранить элементы любых типов данных

Ввод списка:

    list_1 = []
    list_1 = list()
    list_1 = [1,8,3,5,9]

Вывод списка:

    print (list_1) - вывод списка в квадратных скобках
    print (*list_1) - вывод списка без квадртных скобок
    
    for i in list_1: - вывод каждого элемента списка с новой строки
        print(i)
    
    print(len(list_1)) - вывод кол-ва элементов списка
    print(list_1[n]) - вывод n-го элемента списка

*Иные варианты вывода списка см. в главе "Работа с срезами"*

Функции для работы со списками:

    list_1.append(8) - .append() добавляет указанный элемент в конце списка
    list_1.pop(n) - .pop(n) исключает n-й элемент из списка
    list_1.pop() - .pop() исключает последний элемент из списка
    print(list_1.pop()) - .pop() в print() - вывод удаляемого элемента
    list_1.insert(i,n) # - .insert(i,n) - добавляет на i-ю позицию n-й элемент

### Кортежи
Кортеж - это неизменяемый список. 

*Нужные в случае защиты каких-либо данных от изменений (намеренных или случайных). Кортеж занимает меньше места в памяти и работает быстрее, в сравнении со списками.*

    t = () - пустой кортеж (class tuple)
    t = (1,) - кортеж с значениями, в конце обязательно наличие запятой

    v = [1,2,3]
    v = tuple(v) - перевод списка в кортеж (calss list in tuple)
         
    a,b,c = v - распаковка кортежа (присваивание переменным элементов кортежа)

### Словари
Словари - неупорядоченные коллекции произвольных объектов с доступом по ключу.

*В списках в качестве ключа используется индекс элемента. В словаре для определения элемента используется значение ключа (строка, число)*

    d = {}               - создание пустого словаря
    d = dict()           - создание пустого словаря
    d['q'] = 'qwerty'    - добавление ключа и элемента в словарь
    print(d)             - вывод всего словаря
    print(d['q'])        - вывод элемента словаря по ключу
    del d['q']           - удаление элемента из словаря по ключу 

Примеры работы с for:

    dictionary = {'up': 'Вверх', 'down': 'Вниз', 'left': 'Влево'}
    for item in dictionary:
        print('{}: {}'.format(item,dictionary[item]))

    for (k,v) in dictionary.items(): - dictionary.items() представленеи словаря в виде набора кортежей состоящих из ключа и элемента
        print(k,v)                   - вывод кортежа (ключа и элемента)

### Множества
Моножества содержат в себе уникальные элементы, не обязательно упорядоченные. Одно множество может содержать значения любых типов. Вы можете совершать над ними любые стандартные операции, например, объединение, пересечение и разность.


    colors = set()                       - создание пустого множества
    colors = {'red', 'green', 'blue'}    - создание множества
    colors.add('red')                    - доавление в множество значения, если значение уже есть в множестве то оно не будет дублироваться
    colors.add('gray')                   - значение добавляется в множестно неупорядоченно
    colors.remove('red')                 - удаление значения из множества, но если занчения нет в множестве то будет ошибка
    colors.discard('red')                - удаление значения из множества при его наличии, если его нет то пропускает без вывода ошибки
    colors.clear()                       - удаление всех значений из множества

Операции с множествами:

    a = {1,2,3,5,8}
    b = {2,5,8,13,21}
    c = a.copy()            # - копирование множества а в множество с
    u = a.union(b)          # - объединение множества a с множеством b
    i = a.intersection(b)   # - пересечение множества a c множеством b
    d1 = a.difference(b)    # - разность множества а и b (из а вычитаем b)
    d2 = b.difference(a)    # - разность множества b и а (из b вычитаем а)
 
    f = frozenset(a)        # - замороженное множество а (неизменяемое)

![Сводная таблица по встроенным коллекциям](summary_table_by_collections.png)

### List Comprehension
*Одна из культовых фишек Python.* Это упрощенный подход к созданию списка, который задействует цикл for, а также констуркции if-else для определения того, что в итоге окажется в финальном списке.

Примеры:

    list1 = [i for i in range(1,11)]
    list2 = [i for i in range(1,11) if i%2==0]
    list3 = [(i,i) for i in range(1,11) if i%2==0]
    list4 = [i^2 for i in range(1,11) if i%2==0]

## Функции

Функция - это фрагмент рограммы, используемый многократно.

    def function(a, b = '...'):     - значения аргумента могут быть заданы по умолчанию
        ...
        return ...

### Модульность

Импорт модуля и обращение к функции:

    import modul
    print(modul.function1(a,b))   
 
Переименование модуля в используемой программе:

    import modul as m1
    print(m1.function1(a,b))    

Импорт определенной функции модуля:

    from modul import function
    print(function1(a,b))

Импорт всех функций модуля:

    from modul import *
    print(function1(a,b))

### Рекурсия

Рекурсия - это функция, вызывающая сама себя. При описании рекурсии важно указать, когда функции следует остановиться (указать базис рекурсии)

    def fibonachi(n):
       if n in [1,2]:   - базис рекурсии (условие выхода)
           return 1
      return fibonachi(n-1) + fibonachi(n-2)

 